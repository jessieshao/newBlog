(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{277:function(e,t,s){"use strict";s.r(t);var n=s(10),o=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"promise-是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-是什么"}},[e._v("#")]),e._v(" Promise 是什么")]),e._v(" "),t("p",[e._v("Promise 是异步编程的一种解决方案，有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数\n简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。")]),e._v(" "),t("p",[e._v("（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。")]),e._v(" "),t("p",[e._v("（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。（与event不同）")]),e._v(" "),t("h3",{attrs:{id:"基本用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本用法"}},[e._v("#")]),e._v(" 基本用法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const promise = new Promise((resolve, reject) => {\n  resolve('成功');\n}).then(\n  (data) => {\n    console.log('success', data)\n  },\n  (err) => {\n    console.log('faild', err)\n  }\n)\n")])])]),t("h4",{attrs:{id:"实现promise的基本功能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现promise的基本功能"}},[e._v("#")]),e._v(" 实现promise的基本功能")]),e._v(" "),t("ul",[t("li",[e._v("Promise对象是一个构造函数，用来生成Promise实例。")]),e._v(" "),t("li",[e._v("Promise构造函数接收一个"),t("code",[e._v("executor")]),e._v("（执行器）函数作为参数，该函数的两个参数分别是"),t("code",[e._v("resolve")]),e._v("和"),t("code",[e._v("reject")]),e._v("。")]),e._v(" "),t("li",[e._v("Promise 的状态不可逆，默认状态是"),t("code",[e._v("pending")]),e._v("，同时调用 resolve 函数和 reject 函数，默认会采取第一次调用的结果。")]),e._v(" "),t("li",[t("code",[e._v("resolve")]),e._v("接收"),t("code",[e._v("value")]),e._v("保存成功值，可以是"),t("code",[e._v("undefined/thenable/promise")])]),e._v(" "),t("li",[t("code",[e._v("reject")]),e._v("接收"),t("code",[e._v("reason")]),e._v("保存失败值")]),e._v(" "),t("li",[e._v("必须有一个then方法，then 接收两个参数，分别是 promise 成功的回调 "),t("code",[e._v("onFulfilled")]),e._v(", 和 promise 失败的回调 "),t("code",[e._v("onRejected")]),e._v("；")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Promise{\n\tconstructor(executor){\n\t\tthis.status = 'PENDING'\n\t\tthis.value = undefined\n\t\tthis.reason = undefined\n\n\t\tlet resolve = (value) =>{\n            // 状态为 PENDING 时才可以更新状态，防止 executor 中调用了两次 resovle/reject 方法\n            if(this.status ===  'PENDING') {\n              this.status = 'FULFILLED';\n              this.value = value;\n            }\n\t\t}\n\n\t\tlet reject = (reason) =>{\n            if(this.status ===  'PENDING') {\n              this.status = 'REJECTED';\n              this.reason = reason;\n            }\n\t\t}\n\n\t\ttry{\n\t\t\texecutor(resolve,reject)\n\t\t}catch(error){\n\t\t\treject(error)\n\t\t}\n\t}\n\n\tthen(onFulfilled,onRejected){\n      if (this.status === 'FULFILLED') {\n        onFulfilled(this.value)\n      }\n\n      if (this.status === 'REJECTED') {\n        onRejected(this.reason)\n      }\n\t}\t\n}\n")])])]),t("blockquote",[t("p",[e._v("几个需要注意的点：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("resolve")]),e._v("和"),t("code",[e._v("reject")]),e._v("声明写在"),t("code",[e._v("constructor")]),e._v("同级时需要bind绑定"),t("code",[e._v("this")])]),e._v(" "),t("li",[e._v("需要"),t("code",[e._v("try...catch...")]),e._v("捕获异常，调用reject")])])]),e._v(" "),t("h3",{attrs:{id:"异步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步"}},[e._v("#")]),e._v(" 异步")]),e._v(" "),t("p",[e._v("目前基本用法的例子已经可以正确通过了，但是我们都知道，promise是一个异步任务，而我们目前实现的是一个同步任务。所以目前的代码存在问题")]),e._v(" "),t("h4",{attrs:{id:"后续为同步代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#后续为同步代码"}},[e._v("#")]),e._v(" 后续为同步代码")]),e._v(" "),t("p",[e._v("例如在刚刚的例子中最后一句加入"),t("code",[e._v("console.log('end')")])]),e._v(" "),t("p",[e._v("发现end就是最后打印的，这显然不符合promise的执行顺序，promise.then的执行应该在同步函数后，所以需要把onFulfilled、onRejected改为异步函数（此处用宏任务代替微任务）")]),e._v(" "),t("h4",{attrs:{id:"executor为异步函数时"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#executor为异步函数时"}},[e._v("#")]),e._v(" executor为异步函数时")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const promise = new Promise((resolve, reject) => {\n  setTimeout(()=>{\n    console.log('setTimeout')\n    resolve('成功');\n  },0)\n  \n}).then(\n  (data) => {\n    console.log('success', data)\n  },\n  (err) => {\n    console.log('faild', err)\n  }\n)\n")])])]),t("p",[e._v("输出结果为 "),t("code",[e._v("setTimeout")])]),e._v(" "),t("p",[e._v("这段代码的执行顺序为：")]),e._v(" "),t("p",[e._v("实例化promise，执行传入的executor函数，状态为pending，遇到settimeout，setTimeout中的函数放入宏任务队列，执行promise的then方法，promise结束，执行宏任务中的settimeout回调，打印setTimeout，执行resolve。")]),e._v(" "),t("p",[e._v("但是此时.then方法已经执行结束了，所以最终打印的只有settimeout")]),e._v(" "),t("h4",{attrs:{id:"resolve-reject同步执行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#resolve-reject同步执行"}},[e._v("#")]),e._v(" resolve\\reject同步执行")]),e._v(" "),t("p",[e._v("resolve、reject、onFulfilled、onRejected都是回调函数，")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('console.log("START")\nconst p2 = new Promise(resolve => resolve("RESOLVED"))\nconsole.log(p2.value)\nconsole.log("END")\n')])])]),t("p",[e._v("输出")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("START\nRESOLVED\nEND\n")])])]),t("h4",{attrs:{id:"如何把我们的promise改成异步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何把我们的promise改成异步"}},[e._v("#")]),e._v(" 如何把我们的promise改成异步？")]),e._v(" "),t("p",[e._v("思路：reslove\\reject异步调用，then中判断pending状态，使用settimeout")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Promise{\n\tconstructor(executor){\n\t\tthis.status = 'PENDING'\n\t\tthis.value = undefined\n\t\tthis.reason = undefined\n        this.onFulfilledCallback = []\n        this.onRejectedCallback = []\n\n\t\tlet resolve = (value) =>{\n            // 状态为 PENDING 时才可以更新状态，防止 executor 中调用了两次 resovle/reject 方法\n            if(this.status ===  'PENDING') {\n              this.status = 'FULFILLED';\n              this.value = value;\n            }\n\t\t}\n\n\t\tlet reject = (reason) =>{\n            if(this.status ===  'PENDING') {\n              this.status = 'REJECTED';\n              this.reason = reason;\n            }\n\t\t}\n\n\t\ttry{\n\t\t\texecutor(resolve,reject)\n\t\t}catch(error){\n\t\t\treject(error)\n\t\t}\n\t}\n\n\tthen(onFulfilled,onRejected){\n//       if (this.status === 'PENDING') {\n//         setTimeout(()=>{\n//         onFulfilled(this.value)\n//         },0)\n//       }\n      \n      if (this.status === 'FULFILLED') {\n        setTimeout(()=>{\n        onFulfilled(this.value)\n        },0)\n      }\n\n      if (this.status === 'REJECTED') {\n        setTimeout(()=>{\n        onRejected(this.reason)\n        },0)\n      }\n\t}\t\n}\n\nconst promise = new Promise((resolve, reject) => {\n  setTimeout(()=>{\n    console.log('setTimeout')\n    resolve('成功');\n  },0)\n  \n}).then(\n  (data) => {\n    console.log('success', data)\n  },\n  (err) => {\n    console.log('faild', err)\n  }\n)\nconsole.log('end')\n// console.log(\"START\")\n// const p2 = new Promise(resolve => resolve(\"RESOLVED\"))\n// console.log(p2.value)\n// console.log(\"END\")\n")])])]),t("p",[e._v("规定必须给Promise对象传入一个执行函数，否则将会报错。\nPromise中有throw的话，就相当于执行了reject()")])])}),[],!1,null,null,null);t.default=o.exports}}]);