(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{276:function(e,v,t){"use strict";t.r(v);var _=t(10),s=Object(_.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("ul",[v("li",[e._v("所有同步任务都在主线程上执行，形成一个"),v("code",[e._v("执行栈（execution context stack）")])]),e._v(" "),v("li",[e._v("主线程外还有一个“"),v("code",[e._v("任务队列")]),e._v("”，产生新任务时IO线程就将任务添加在队列尾部，要执行任务渲染主线程就会循环地从队列头部取出执行")]),e._v(" "),v("li",[e._v("在任务队列中，其实还分为"),v("code",[e._v("宏任务队列（Task Queue）")]),e._v("和"),v("code",[e._v("微任务队列（Microtask Queue）")]),e._v("，对应的里面存放的就是宏任务和微任务。宏任务和微任务都是异步任务。")])]),e._v(" "),v("h3",{attrs:{id:"执行栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#执行栈"}},[e._v("#")]),e._v(" 执行栈")]),e._v(" "),v("p",[e._v("后进先出，存放的是代码执行期间的所有执行上下文")]),e._v(" "),v("p",[e._v("入栈--\x3e执行--\x3e(调用其他函数--\x3e执行--\x3e执行完毕--\x3e出栈)--\x3e执行完毕--\x3e出栈")]),e._v(" "),v("p",[e._v("分配的调用栈空间被占满时会引发”堆栈溢出“的报错")]),e._v(" "),v("h3",{attrs:{id:"任务队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#任务队列"}},[e._v("#")]),e._v(" 任务队列")]),e._v(" "),v("p",[e._v("代码在执行栈中调用时，同步任务立即执行，异步任务也会在执行栈中，但是解析出的"),v("code",[e._v("回调函数")]),e._v("会放入"),v("code",[e._v("任务队列")]),e._v("。同步任务执行完毕后，主线程清空，依次执行任务队列中的任务。")]),e._v(" "),v("blockquote",[v("p",[e._v("这里有个重点，就是异步任务不是直接进入任务队列的，等执行到异步函数（任务）的回调函数推入到任务队列中。")])]),e._v(" "),v("h4",{attrs:{id:"宏任务队列-task-queue"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#宏任务队列-task-queue"}},[e._v("#")]),e._v(" 宏任务队列（Task Queue）")]),e._v(" "),v("p",[e._v("存放宏任务，例如"),v("code",[e._v("script（全局任务）, setTimeout, setInterval, setImmediate, I/O, UI rendering")])]),e._v(" "),v("blockquote",[v("p",[e._v("浏览器中"),v("code",[e._v("script")]),e._v("就是第一个宏任务（"),v("code",[e._v("task")]),e._v("）\n下一个"),v("code",[e._v("task")]),e._v("执行前页面会重新渲染")])]),e._v(" "),v("h4",{attrs:{id:"微任务队列-microtask-queue"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#微任务队列-microtask-queue"}},[e._v("#")]),e._v(" 微任务队列（Microtask Queue）")]),e._v(" "),v("p",[e._v("存放微任务，例如"),v("code",[e._v("process.nextTick, Promise, Object.observer, MutationObserver")])]),e._v(" "),v("blockquote",[v("p",[e._v("执行时机在上一个宏任务结束后，下一个宏任务执行前")])]),e._v(" "),v("h4",{attrs:{id:"任务入队"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#任务入队"}},[e._v("#")]),e._v(" 任务入队")]),e._v(" "),v("p",[e._v("线程是如何区分宏任务、微任务并且放入队列中的？\n首先浏览器是多进程的，一个tab页面有一个主进程，该进程可以有多个线程，这些线程共享资源（代码、状态等）")]),e._v(" "),v("ul",[v("li",[e._v("JS引擎线程：也称为JS内核，负责处理Javascript脚本程序（例如V8引擎），只有一个，所以JS是"),v("code",[e._v("单线程")])]),e._v(" "),v("li",[e._v("GUI渲染线程：渲染界面，解析html、css、dom树、render树、布局、绘制等。"),v("code",[e._v("注意：与JS引擎线程互斥")])]),e._v(" "),v("li",[e._v("事件触发线程：用来控制事件循环，当"),v("code",[e._v("click")]),e._v("、"),v("code",[e._v("mouse")]),e._v("触发时，将回调放入队列中")]),e._v(" "),v("li",[e._v("http异步网络请求线程：处理用户的get、post等请求，等返回结果后将回调函数推入到任务队列；")]),e._v(" "),v("li",[e._v("定时触发器线程：setInterval、setTimeout等待时间结束后，会把执行函数推入任务队列中；")])]),e._v(" "),v("h3",{attrs:{id:"事件循环event-loop"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件循环event-loop"}},[e._v("#")]),e._v(" 事件循环Event Loop")]),e._v(" "),v("p",[e._v("宏任务--\x3e微任务--\x3e微任务清空--\x3e宏任务--\x3e...")]),e._v(" "),v("p",[e._v("1、从宏任务队列中，按照入队顺序，找到第一个执行的宏任务，放入调用栈，开始执行；")]),e._v(" "),v("p",[e._v("2、执行完该宏任务下所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序，依次执行其中的微任务，直至微任务队列清空为止；")]),e._v(" "),v("p",[e._v("3、当微任务队列清空后，一个事件循环结束；")]),e._v(" "),v("p",[e._v("4、接着从宏任务队列中，找到下一个执行的宏任务，开始第二个事件循环，直至宏任务队列清空为止。")]),e._v(" "),v("blockquote",[v("p",[e._v("注意：只有一个微任务队列，新的微任务也会被放在这个队列中，直到所有微任务都被执行")])])])}),[],!1,null,null,null);v.default=s.exports}}]);