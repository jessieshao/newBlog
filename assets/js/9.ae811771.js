(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{277:function(e,t,v){"use strict";v.r(t);var _=v(10),s=Object(_.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("ul",[t("li",[e._v("所有同步任务都在主线程上执行，形成一个"),t("code",[e._v("执行栈（execution context stack）")])]),e._v(" "),t("li",[e._v("主线程外还有一个“"),t("code",[e._v("任务队列")]),e._v("”，产生新任务时IO线程就将任务添加在队列尾部，要执行任务渲染主线程就会循环地从队列头部取出执行")]),e._v(" "),t("li",[e._v("在任务队列中，其实还分为"),t("code",[e._v("宏任务队列（Task Queue）")]),e._v("和"),t("code",[e._v("微任务队列（Microtask Queue）")]),e._v("，对应的里面存放的就是宏任务和微任务。宏任务和微任务都是异步任务。")])]),e._v(" "),t("h3",{attrs:{id:"执行栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行栈"}},[e._v("#")]),e._v(" 执行栈")]),e._v(" "),t("p",[e._v("后进先出，存放的是代码执行期间的所有执行上下文\n入栈--\x3e执行--\x3e(调用其他函数--\x3e执行--\x3e执行完毕--\x3e出栈)--\x3e执行完毕--\x3e出栈\n分配的调用栈空间被占满时会引发”堆栈溢出“的报错")]),e._v(" "),t("h3",{attrs:{id:"任务队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#任务队列"}},[e._v("#")]),e._v(" 任务队列")]),e._v(" "),t("p",[e._v("代码在执行栈中调用时，同步任务立即执行，异步任务也会在执行栈中，但是解析出的"),t("code",[e._v("回调函数")]),e._v("会放入"),t("code",[e._v("任务队列")]),e._v("。同步任务执行完毕后，主线程清空，依次执行任务队列中的任务。")]),e._v(" "),t("blockquote",[t("p",[e._v("这里有个重点，就是异步任务不是直接进入任务队列的，等执行到异步函数（任务）的回调函数推入到任务队列中。")])]),e._v(" "),t("h4",{attrs:{id:"宏任务队列-task-queue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#宏任务队列-task-queue"}},[e._v("#")]),e._v(" 宏任务队列（Task Queue）")]),e._v(" "),t("p",[e._v("存放宏任务，例如"),t("code",[e._v("script（全局任务）, setTimeout, setInterval, setImmediate, I/O, UI rendering")])]),e._v(" "),t("blockquote",[t("p",[e._v("浏览器中"),t("code",[e._v("script")]),e._v("就是第一个宏任务（"),t("code",[e._v("task")]),e._v("）\n下一个"),t("code",[e._v("task")]),e._v("执行前页面会重新渲染")])]),e._v(" "),t("h4",{attrs:{id:"微任务队列-microtask-queue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#微任务队列-microtask-queue"}},[e._v("#")]),e._v(" 微任务队列（Microtask Queue）")]),e._v(" "),t("p",[e._v("存放微任务，例如"),t("code",[e._v("process.nextTick, Promise, Object.observer, MutationObserver")])]),e._v(" "),t("blockquote",[t("p",[e._v("执行时机在上一个宏任务结束后，下一个宏任务执行前")])]),e._v(" "),t("h4",{attrs:{id:"任务入队"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#任务入队"}},[e._v("#")]),e._v(" 任务入队")]),e._v(" "),t("p",[e._v("线程是如何区分宏任务、微任务并且放入队列中的？\n首先浏览器是多进程的，一个tab页面有一个主进程，该进程可以有多个线程，这些线程共享资源（代码、状态等）")]),e._v(" "),t("ul",[t("li",[e._v("JS引擎线程：也称为JS内核，负责处理Javascript脚本程序（例如V8引擎），只有一个，所以JS是"),t("code",[e._v("单线程")])]),e._v(" "),t("li",[e._v("GUI渲染线程：渲染界面，解析html、css、dom树、render树、布局、绘制等。"),t("code",[e._v("注意：与JS引擎线程互斥")])]),e._v(" "),t("li",[e._v("事件触发线程：用来控制事件循环，当"),t("code",[e._v("click")]),e._v("、"),t("code",[e._v("mouse")]),e._v("触发时，将回调放入队列中")]),e._v(" "),t("li",[e._v("http异步网络请求线程：处理用户的get、post等请求，等返回结果后将回调函数推入到任务队列；")]),e._v(" "),t("li",[e._v("定时触发器线程：setInterval、setTimeout等待时间结束后，会把执行函数推入任务队列中；")])]),e._v(" "),t("h3",{attrs:{id:"事件循环event-loop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件循环event-loop"}},[e._v("#")]),e._v(" 事件循环Event Loop")]),e._v(" "),t("p",[e._v("宏任务--\x3e微任务--\x3e微任务清空--\x3e宏任务--\x3e...\n1、从宏任务队列中，按照入队顺序，找到第一个执行的宏任务，放入调用栈，开始执行；\n2、执行完该宏任务下所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序，依次执行其中的微任务，直至微任务队列清空为止；\n3、当微任务队列清空后，一个事件循环结束；\n4、接着从宏任务队列中，找到下一个执行的宏任务，开始第二个事件循环，直至宏任务队列清空为止。")]),e._v(" "),t("blockquote",[t("p",[e._v("注意：只有一个微任务队列，新的微任务也会被放在这个队列中，直到所有微任务都被执行")])])])}),[],!1,null,null,null);t.default=s.exports}}]);