(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{279:function(e,t,s){"use strict";s.r(t);var n=s(10),r=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"promise-是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-是什么"}},[e._v("#")]),e._v(" Promise 是什么")]),e._v(" "),t("p",[e._v("Promise 是异步编程的一种解决方案，有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数\n简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。")]),e._v(" "),t("p",[e._v("（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。")]),e._v(" "),t("p",[e._v("（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。（与event不同）")]),e._v(" "),t("h3",{attrs:{id:"基本用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本用法"}},[e._v("#")]),e._v(" 基本用法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const promise = new Promise((resolve, reject) => {\n  resolve('成功');\n}).then(\n  (data) => {\n    console.log('success', data)\n  },\n  (err) => {\n    console.log('faild', err)\n  }\n)\n")])])]),t("h4",{attrs:{id:"实现promise的基本功能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现promise的基本功能"}},[e._v("#")]),e._v(" 实现promise的基本功能")]),e._v(" "),t("ul",[t("li",[e._v("Promise对象是一个构造函数，用来生成Promise实例。")]),e._v(" "),t("li",[e._v("Promise构造函数接收一个"),t("code",[e._v("executor")]),e._v("（执行器）函数作为参数，该函数的两个参数分别是"),t("code",[e._v("resolve")]),e._v("和"),t("code",[e._v("reject")]),e._v("。")]),e._v(" "),t("li",[e._v("Promise 的状态不可逆，默认状态是"),t("code",[e._v("pending")]),e._v("，同时调用 resolve 函数和 reject 函数，默认会采取第一次调用的结果。")]),e._v(" "),t("li",[t("code",[e._v("resolve")]),e._v("接收"),t("code",[e._v("value")]),e._v("保存成功值，可以是"),t("code",[e._v("undefined/thenable/promise")])]),e._v(" "),t("li",[t("code",[e._v("reject")]),e._v("接收"),t("code",[e._v("reason")]),e._v("保存失败值")]),e._v(" "),t("li",[e._v("必须有一个then方法，then 接收两个参数，分别是 promise 成功的回调 "),t("code",[e._v("onFulfilled")]),e._v(", 和 promise 失败的回调 "),t("code",[e._v("onRejected")]),e._v("；")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Promise{\n\tconstructor(executor){\n\t\tthis.status = 'PENDING'\n\t\tthis.value = undefined\n\t\tthis.reason = undefined\n\n\t\tlet resolve = (value) =>{\n            // 状态为 PENDING 时才可以更新状态，防止 executor 中调用了两次 resovle/reject 方法\n            if(this.status ===  'PENDING') {\n              this.status = 'FULFILLED';\n              this.value = value;\n            }\n\t\t}\n\n\t\tlet reject = (reason) =>{\n            if(this.status ===  'PENDING') {\n              this.status = 'REJECTED';\n              this.reason = reason;\n            }\n\t\t}\n\n\t\ttry{\n\t\t\texecutor(resolve,reject)\n\t\t}catch(error){\n\t\t\treject(error)\n\t\t}\n\t}\n\n\tthen(onFulfilled,onRejected){\n      if (this.status === 'FULFILLED') {\n        onFulfilled(this.value)\n      }\n\n      if (this.status === 'REJECTED') {\n        onRejected(this.reason)\n      }\n\t}\t\n}\n")])])]),t("blockquote",[t("p",[e._v("几个需要注意的点：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("resolve")]),e._v("和"),t("code",[e._v("reject")]),e._v("声明写在"),t("code",[e._v("constructor")]),e._v("同级时需要bind绑定"),t("code",[e._v("this")])]),e._v(" "),t("li",[e._v("需要"),t("code",[e._v("try...catch...")]),e._v("捕获异常，调用reject")])])]),e._v(" "),t("p",[e._v("规定必须给Promise对象传入一个执行函数，否则将会报错。\nPromise中有throw的话，就相当于执行了reject()")])])}),[],!1,null,null,null);t.default=r.exports}}]);